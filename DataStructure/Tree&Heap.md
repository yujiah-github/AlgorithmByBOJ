## 힙 작업 알고리즘과 구현
- 힙을 잘 다루려면 트리에 대한 지식도 있어야합니다.
- **트리 -> 힙 -> 코드** 순서대로 발표 진행하겠습니다.

### 1. 트리란?
- 자료구조에서 트리는 **부모 - 자식 관계**로 정의하고, 부모에서 자식으로 간선이 이어져 있는 **유향 그래프***이다.
- 자료구조에서 트리는 **부모가 없는 루트 노드를 정의**한다.

![](https://velog.velcdn.com/images/cil05265/post/a5db801e-8f1a-4b77-b052-b82d6bfd80f1/image.png)

- 트리는 항상 **루트(Root)** 에서부터 시작된다. 
- 루트는 **자식(Child) 노드**를 가지며, **간선(Edge)** 으로 연결되어 있다.

> **노드** : 트리를 구성하는 기본 원소
    **루트 노드** : 트리에서 부모가 없는 최상위 노드, 트리의 시작점
    **부모 노드** : 루트 노드 방향으로 직접 연결된 노드
    **자식 노드** : 루트 노드 반대 방향으로 직접 연결된 노드
    **형제 노드** : 같은 부모 노드를 갖는 노드들
    **리프 노드**: 루트 노드를 제외한 차수가 1인 정점을 뜻한다. 즉, 자식이 없는 노드라는 것이다. **단말 노드** 라고 부르기도 한다.

- 자식 노드의 개수는 **차수(Degree)** 라고 하며, 크기(Size)는 **자신을 포함한 모든 자식 노드의 개수**다.
- 높이(Height)는 **가장 긴 루트 경로의 길이** 까지의 거리, 깊이(Depth)는 **루트에서부터 현재 노드** 까지의 거리다.
- 트리는 그 자식도 트리인 **서브트리(Subtree)** 구성을 띤다.
- 레벨(Level)은 **0** 에서부터 시작하고 노드까지 연결된 **간선 수의 합**을 의미한다.
- 트리는 항상 **단방향(Uni-Directional)** 이기 때문에, 간선의 화살표는 생략 가능하다. 그림에서도 마찬가지로 생략해서 표현했고 일반적으로 방향은 **위에서 아래** 로 향한다.

### 2. 이진 트리

![](https://velog.velcdn.com/images/cil05265/post/e785d6b8-0179-40f0-8650-9f7f87211084/image.png)


- 부모 노드 밑의 **자식 노드 개수(=차수, degree)를 최대 2개로 제한** 하는, 트리의 가장 간단한 형태다. 두 자식 노드를 보통 왼쪽 자식과 오른쪽 자식으로 구분짓는다.

##### 이진트리의 종류는 다음과 같다.

![](https://velog.velcdn.com/images/cil05265/post/588e3708-c114-4e2b-8968-5d6c72dc54e3/image.png)

1. **정 이진 트리(full binary tree)**: 모든 트리의 자식은 0개나 2개다.

2. **포화 이진 트리(perfect binary tree)**: 모든 리프 노드의 높이가 같고 **리프 노드가 아닌 노드는 모두 2개의 자식을 갖는다.** 이진 트리에서 리프 높이의 최대치가 n일 때 가장 많이 존재할 수 있는 노드의 수는 2n-1개인데 포화 이진 트리는 이 개수를 모두 채운 이진 트리라고도 볼 수 있다. 또한, 모든 포화 이진 트리는 정 이진 트리이다.

3. **완전 이진 트리(complete binary tree)**: 모든 리프노드의 높이가 최대 1 차이가 나고, 모든 노드의 오른쪽 자식이 있으면 왼쪽 자식이 있는 이진트리이다. **다시 말해 트리의 원소를 왼쪽에서 오른쪽으로 하나씩 빠짐없이 채워나간 형태이다.** 포화 이진 트리는 완전 이진 트리의 부분집합이다. 단, 포화 이진 트리가 아닌 완전 이진 트리는 정 이진 트리일 수도 있고 아닐 수도 있다.

##### 완전 이진 트리의 경우 왼쪽부터 빠짐없이 채워져있다는 성질을 이용해 배열을 사용하여 구현 하기도 한다. 1번부터 시작하는 배열을 생각하면 n번째 원소의 왼쪽 자식은 2n, 오른쪽 자식은 2n+1번째 원소로 구성하면 된다. 또 n번째 원소의 부모 노드는 [n/2]번째 원소가 된다.

#### 2.1 이진 트리 순회 방법
- **중위 순회(In-order traversal)** : 왼쪽 자손, 자신, 오른쪽 자손 순서로 방문하는 순회 방법. 이진 탐색 트리를 중위 순회하면 정렬된 결과를 얻을 수 있다. 스택을 통해 구현 가능.
- **전위 순회(Pre-order traversal)**: 자신, 왼쪽 자손, 오른쪽 자손 순서로 방문하는 순회 방법. 스택을 통해 구현 가능.
- **후위 순회(Post-order traversal** : 왼쪽 자손, 오른쪽 자손, 자신 순서로 방문하는 순회 방법. 스택을 통해 구현 가능.
- **레벨 순서 순회(Level-order traversal)**: 너비 우선 순회(Breadth-First traversal)라고도 한다. **큐를 통해 구현 가능.**

다음의 사진을 보세요.
![](https://velog.velcdn.com/images/cil05265/post/3b43ac31-ff1f-4a2f-813d-1939507ff9df/image.gif)

순회 방법에 따라 경로가 다릅니다.

- **중위 순회(In-order traversal)** : 1 3 4 6 7 8 10 13 14
- **전위 순회(Pre-order traversal)**: 8 3 1 6 4 7 10 14 13
- **후위 순회(Post-order traversal** : 1 4 7 6 3 13 14 10 8
- **레벨 순서 순회(Level-order traversal)**: 8 3 10 1 6 14 4 7 13

### 3. 이진 탐색 트리
![](https://velog.velcdn.com/images/cil05265/post/f4d88b4b-98da-4c5d-8df1-febaaaf08123/image.png)

- 이진 트리의 일종으로, 노드의 왼쪽 가지에는 노드의 값보다 **작은 값** 들만 있고, 오른쪽 가지에는 **큰 값** 들만 있도록 구성되었다. 자식 노드들도 동일한 방법으로 정렬되어 노드의 왼쪽 자식의 왼쪽 가지에는 왼쪽 자식이 가진 값보다 작은 값만 있고, 왼쪽 자식의 오른쪽 가지에는 왼쪽 자식의 값보다 큰 값들만 있다. **이진 탐색 트리의 어느 노드를 잡아도 동일한 규칙으로 정렬이 되어 있다.**

- 이렇게 구성해 두면 어떤 값 n을 찾을 때, **루트 노드와 비교해서 n이 더 작다면 루트 노드보다 큰 값들만 모여 있는 오른쪽 가지는 전혀 탐색할 필요가 없다.** 마찬가지로 루트 노드의 왼쪽 자식보다 n이 크다면 왼쪽 자식의 왼쪽 가지는 탐색할 필요가 없다. **다시 말해 트리 자체가 이진 탐색을 하기에 적합한 구성이 되는 것이다.** 또한 값을 찾을 때뿐만이 아니라 값을 삽입하거나 삭제할 때도 똑같은 과정을 거치므로, 이상적인 상황에서 탐색/삽입/삭제 모두 시간복잡도가 **O(log N)** 이 된다.

![](https://velog.velcdn.com/images/cil05265/post/a8c2e12e-27cc-46f4-b990-e79a445d0b21/image.png)

> 예시) 8 찾기
    1. 루트 노드 15보다 작으므로 **왼쪽** 으로 이동한다.
    2. 노드 10보다 크므로 **오른쪽** 으로 이동한다.
    3. 노드 5보다 크므로 **오른쪽** 으로 이동한다.
    4. 노드 7보다 크므로 **오른쪽** 으로 이동한다.
