## Graph & Tree
- 그래프와 트리의 관계를 그림으로 나타내면 다음과 같다.
![](https://velog.velcdn.com/images/cil05265/post/c7b41970-2a6f-404b-b8f0-9216f1f2f70c/image.png)

![](https://velog.velcdn.com/images/cil05265/post/59b7bbac-67bb-462d-ad53-65248e2472f1/image.png)

### 그래프란?
- 그래프는 노드(하나의 점)와 노드 간을 연결하는 간선으로 구성된 자료 구조이다.

### 그래프의 특징
- 그래프는 순환 혹은 비순환 구조를 이룬다
- 그래프는 방향이 있는 그래프와 방향이 없는 그래프가 있다.
- 루트 노드의 개념이 없다 / 부모-자식 관계라는 개념이 없다.
- 2개 이상의 경로가 가능하다.(무방향, 방향, 양방향 가능)
- 그래프는 네트워크 모델이다.

67bb-462d-ad53-65248e2472f1/image.png)
![](https://velog.velcdn.com/images/cil05265/post/9f0bf23e-14eb-4c03-bc63-ac5a213594a5/image.png)

### 트리란?
- 트리는 그래프와 같이 노드와 노드간을 연결하는 간선으로 구성된 자료구조이다.
- 그러나 트리는 그래프 중에서도 특수한 케이스에 해당하는 자료구조이다.
- 트리는 두 개의 노드 사이에 반드시 1개의 경로만을 가지며 사이클이 존재하지 않는 방향 그래프이다.
- 이러한 특성 때문에 **'최소 연결 트리'**라고 부르기도 한다.
- 부모-자식 관계가 성립하기 때문에 계층형 모델이라고도 한다.

### 트리의 특징
- 부모-자식 관계가 존재해 레벨이 존재한다.(최상위 노드=Root)
- 노드가 N개이면 간선은 N-1개 / 각 레벨 k에 존재하는 노드는 2^k개(완전이진트리의 경우)
- 방향성이 존재하고 사이클은 존재하시 않는다.(비순환)
- 트리의 순회는 **전위순회, 중위순회, 후위순회** 3가지가 존재한다.

### 정리
||그래프 |트리|
|----------|----------|----------|
|방향성| 방향,무방향 | 방향만|
|사이클| 순환, 비순환, 자기순환 |비순환만|
|루트노드| 루트 개념 없음| 한 개의 루트 존재|
|부모-자식| 부모-자식 개념없음| 1개의 부모노드(루트 제외)|
|모델 |네트워크 모델| 계층 모델
|간선 수| 자유| N-1개|

### 그래프의 구현
#### 1. 인접 행렬
![](https://velog.velcdn.com/images/cil05265/post/55e7ae35-2003-4882-9769-7502ae46409b/image.png)

- 그래프의 정점을 2차원 배열로 만든 것이다.
- 정점의 개수가 n이라면 n*n 형태의 2차원 배열이 인접 행렬로 사용된다.
- 인접 행렬에서 행과 열은 정점을 의미하며, 각각의 원소들은 정점 간의 간선을 나타낸다.
- 무방향 그래프는 인접 행렬이 대칭적 구조를 가진다. **(두 개의 정점에서 간선이 동시에 연결되어 있기 때문)**
- 가중치 그래프의 경우 행렬에서 0과 1이 아니라 각 간선의 가중치 값이 저장된다. **(이 경우 가중치가 0인 것과 간선이 없는 것이 구별돼야 함)**

#### 장점
- 2차원 배열에 모든 정점들의 간선 정보가 있기 때문에, 두 정점을 연결하는 간선을 조회할 때 O(1) 시간복잡도로 가능하다.
- 정점(i)의 차수를 구할 때는 다음과 같이 인접행렬(M)의 i번째 행의 값을 모두 더하면 되므로 O(n)의 시간복잡도를 가진다.

#### 단점
- 간선의 수와 무관하게 항상 n² 크기의 2차원 배열이 필요하므로 메모리 공간이 낭비된다.
- 그래프의 모든 간선의 수를 알아내려면 인접행렬 전체를 확인해야 하므로 O(n²)의 시간이 소요된다.

#### 2. 인접 리스트
![](https://velog.velcdn.com/images/cil05265/post/3427f0ae-3f21-4299-9633-48ae002aaf6d/image.png)

- 그래프의 각 정점에 인접한 정점들을 연결리스트(Linked List)로 표현하는 방법이다.
- 즉 정점의 개수만큼 인접리스트가 존재하며, 각각의 인접리스트에는 인접한 정점 정보가 저장되는 것이다.
- 그래프는 각 인접리스트에 대한 헤드포인터를 배열로 갖는다.
- 무방향 그래프의 경우 간선이 추가되면 각각의 정점의 인접리스트에 반대편 정점의 노드를 추가해야 한다.

#### 장점
- 존재하는 간선만 관리하면 되므로 메모리 사용 측면에서 보다 효율적이다.
- 그래프의 모든 간선의 수를 알아내려면 각 정점의 헤더 노드부터 모든 인접리스트를 탐색해야 하므로 O(n+e)의 시간이 소요된다.

#### 단점
- 두 정점을 연결하는 간선을 조회하거나 정점의 차수를 알기 위해서는 정점의 인접 리스트를 탐색해야 하므로 정점의 차수만큼의 시간이 필요하다. O(degree(v))
- 구현이 비교적 어렵다.

